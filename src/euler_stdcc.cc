#include <iostream>
#include <cmath>
#include <limits>
#include <iomanip>
#include <string>
#include <sstream>
#include <vector>
#include <cstdint>
#include <bitset>
#include <exception>
#include <algorithm>
#include <functional>
#include <iterator>
#include <numeric>
#include <vector>
#include <set>

// Helper functions
bool IsPrime(uint64_t test) {
  for (uint64_t i = 3;i*i <= test; i = 2+i)
    if (test % i == 0)
      return false;
    return true;
}

std::string IntToString(size_t num) {
  std::stringstream stream;
  stream << num;
  return stream.str();
}

bool IsPallindrom(size_t num) {
  std::string stringnum= IntToString(num);
  auto it_begin = stringnum.begin();
  auto it_end = stringnum.end() - 1;
  for(; it_begin < it_end; ++it_begin, --it_end) {
    if (*it_begin != *it_end)
      return false;
  }
  return true;
}
// If we list all the natural numbers below 10 that are multiples of 3 or 5, we
//  get 3, 5, 6 and 9.
// The sum of these multiples is 23.
// Find the sum of all the multiples of 3 or 5 below 1000.
int prob1() {
  int answer = 0;
  for(int i = 0; i < 1000; ++i) {
    if (i % 3 == 0 || i % 5 == 0)
      answer = answer + i;
  }
  return answer;
}

// Each new term in the Fibonacci sequence is generated by adding the previous
// two // terms. By starting with 1 and 2, the first 10 terms will be:
// 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ...
// By considering the terms in the Fibonacci sequence whose values do not exceed
// four million, find the sum of the even-valued terms.
unsigned long prob2() {
  unsigned long f = 0;
  unsigned long i = 1;
  unsigned long j = 2;
  unsigned long x = 0;
  while (j <= 4000000) {
    if (j % 2 == 0)
      x = j + x;
    f = i;
    i = j;
    j = j + f;
  }
  return x;
}

// The prime factors of 13195 are 5, 7, 13 and 29.
// What is the largest prime factor of the number 600851475143 ?
uint64_t prob3() {
  uint64_t x, y;
  uint64_t z = 600851475143ULL;
  for (uint64_t i = 11; i*i <= z; i = i + 2) {
    if ((z % i == 0) && (IsPrime(i))) {
      y = z / i;
      if (IsPrime(y) && (y>i)) {
        x = y;
      } else {
        x = i;
      }
    }
  }
  return x;
}

// A palindromic number reads the same both ways. The largest palindrome made
// from // the product of two 2-digit numbers is 9009 = 91  99.
//
// Find the largest palindrome made from the product of two 3-digit numbers.
// Palindromic numbers work in any base
size_t prob4() {
  static size_t x =0;
  for(size_t i = 999; i > 99; --i) {
    for(size_t j = 999; j > 99; --j) {
      if (IsPallindrom(i*j) && (i*j) > x)
        x = (i*j);
    }
  }
  return x;
  // this can be better we do not need to go all the way through
}

// 2520 is the smallest number that can be divided by each of the numbers from 1
// to 10 without any remainder.
// What is the smallest positive number that is evenly divisible by all of the
// numbers from 1 to 20?

size_t prob5() {
  size_t num = 20;
  while(true) {
    for(size_t i = 1; i <=20; ++i) {
      if (num % i != 0)
        break;
      if (i == 20)
        return num;
    }
    ++num;
  }
}

// The sum of the squares of the first ten natural numbers is,
//
// 12 + 22 + ... + 102 = 385
// The square of the sum of the first ten natural numbers is,
//
// (1 + 2 + ... + 10)2 = 552 = 3025
// Hence the difference between the sum of the squares of the first ten natural
// numbers and the square of the sum is 3025  385 = 2640.
//
// Find the difference between the sum of the squares of the first one hundred
// natural numbers and the square of the sum.
size_t prob6() {
  size_t num = 100;
  size_t sums = 0;
  size_t squares =0;
  sums = (num*(num +1))/2;
  squares = (2*num +1)*(num +1)*num/6;
  return (sums*sums) - squares;
}

// By listing the first six prime numbers: 2, 3, 5, 7, 11, and 13, we can see
// that // the 6th prime is 13.
// What is the 10001st prime number?
size_t prob7() {
  size_t prime_test = 3;
  size_t num_primes = 2;
  while(num_primes <= 10001) {
    if (IsPrime(prime_test)) {
      ++num_primes;
    }
    prime_test+=2;
  }
  return prime_test - 2;
}

//Find the greatest product of five consecutive digits in the 1000-digit number.
size_t prob8() {
  std::string str = "7316717653133062491922511967442657474235534919493496983520312774506326239578318016984801869478851843858615607891129494954595017379583319528532088055111254069874715852386305071569329096329522744304355766896648950445244523161731856403098711121722383113622298934233803081353362766142828064444866452387493035890729629049156044077239071381051585930796086670172427121883998797908792274921901699720888093776657273330010533678812202354218097512545405947522435258490771167055601360483958644670632441572215539753697817977846174064955149290862569321978468622482839722413756570560574902614079729686524145351004748216637048440319989000889524345065854122758866688116427171479924442928230863465674813919123162824586178664583591245665294765456828489128831426076900422421902267105562632111110937054421750694165896040807198403850962455444362981230987879927244284909188845801561660979191338754992005240636899125607176060588611646710940507754100225698315520005593572972571636269561882670428252483600823257530420752963450";
  size_t current = 0;
  size_t count = 0;
  size_t last = 0;
  size_t big = 0;
  for(auto it = str.begin(); it != str.end() - 5; ++it) {
    current = *(it);
    big = str[count] *
    str[count + 1] *
    str[count + 2] *
    str[count + 3] *
    str[count + 4];
    if (big > last)
      last = big;
    std::cout << last << std::endl;
    ++count;
  }
  
  return last;
}

// A Pythagorean triplet is a set of three natural numbers, a  b  c, for which,
// a2 + b2 = c2
// For example, 32 + 42 = 9 + 16 = 25 = 52.
// There exists exactly one Pythagorean triplet for which a + b + c = 1000.
// Find the product abc.
size_t prob9() {
  size_t num = 1000;
  size_t a;
  for (a = 1; a <= num/3; a++) {
    for (size_t b = a + 1; b <= num/2; b++) {
      size_t c = num - a - b;
      if ( c > 0 && (a*a + b*b == c*c) ) {
        std::cout << "a= " << a << " b= " << b << " c= " << c << std::endl;
        return a*b*c;
      }
    }
  }
  return 1;
}

//Find the sum of all the primes below two million.
// Aha seive Eratosthenes  problem
unsigned long long prob10() {
  size_t number = 2000000;
  std::vector<size_t> seive(number);
  
  for(size_t i = 0; i < number; ++i) {
    seive.at(i) = i;
  }
  
  for (size_t i = 2;i*i < number ; ++i) {
    while (seive[i] == 0) ++i;
    for (size_t j = i*2; j < number ; j += i) { seive.at(j) = 0;} //remove divisors
  }
  return std::accumulate(seive.begin() + 2, seive.end(), 0ULL);
}

//What is the sum of the digits of the number 2^1000?
char carry( char curr, char prev )
{
  return curr + (prev / 10);
}

// What is the greatest product of four adjacent numbers in any direction (up, down, left, right, or diagonally) in the 2020 grid?
uint32_t prob11() {
  std::vector<std::vector<uint32_t>> matrix = {
    {8, 2, 22, 97, 38, 15, 00, 40, 00, 75, 4, 5, 7, 78, 52, 12, 50, 77, 91, 8},
    {49, 49, 99, 40, 17, 81, 18, 57, 60, 87, 17, 40, 98, 43, 69, 48, 4, 56, 62, 00},
    {81, 49, 31, 73, 55, 79, 14, 29, 93, 71, 40, 67, 53, 88, 30, 3, 49, 13, 36, 65},
    {52, 70, 95, 23, 4, 60, 11, 42, 69, 24, 68, 56, 1, 32, 56, 71, 37, 2, 36, 91},
    {22, 31, 16, 71, 51, 67, 63, 89, 41, 92, 36, 54, 22, 40, 40, 28, 66, 33, 13, 80},
    {24, 47, 32, 60, 99, 3, 45, 2, 44, 75, 33, 53, 78, 36, 84, 20, 35, 17, 12, 50},
    {32, 98, 81, 28, 64, 23, 67, 10, 26, 38, 40, 67, 59, 54, 70, 66, 18, 38, 64, 70},
    {67, 26, 20, 68, 2, 62, 12, 20, 95, 63, 94, 39, 63, 8, 40, 91, 66, 49, 94, 21},
    {24, 55, 58, 5, 66, 73, 99, 26, 97, 17, 78, 78, 96, 83, 14, 88, 34, 89, 63, 72},
    {21, 36, 23, 9, 75, 00, 76, 44, 20, 45, 35, 14, 0, 61, 33, 97, 34, 31, 33, 95},
    {78, 17, 53, 28, 22, 75, 31, 67, 15, 94, 3, 80, 4, 62, 16, 14, 9, 53, 56, 92},
    {16, 39, 5, 42, 96, 35, 31, 47, 55, 58, 88, 24, 0, 17, 54, 24, 36, 29, 85, 57},
    {86, 56, 0, 48, 35, 71, 89, 7, 5, 44, 44, 37, 44, 60, 21, 58, 51, 54, 17, 58},
    {19, 80, 81, 68, 5, 94, 47, 69, 28, 73, 92, 13, 86, 52, 17, 77, 4, 89, 55, 40},
    {4, 52, 8, 83, 97, 35, 99, 16, 7, 97, 57, 32, 16, 26, 26, 79, 33, 27, 98, 66},
    {88, 36, 68, 87, 57, 62, 20, 72, 3, 46, 33, 67, 46, 55, 12, 32, 63, 93, 53, 69},
    {4, 42, 16, 73, 38, 25, 39, 11, 24, 94, 72, 18, 8, 46, 29, 32, 40, 62, 76, 36},
    {20, 69, 36, 41, 72, 30, 23, 88, 34, 62, 99, 69, 82, 67, 59, 85, 74, 4, 36, 16},
    {20, 73, 35, 29, 78, 31, 90, 1, 74, 31, 49, 71, 48, 86, 81, 16, 23, 57, 5, 54},
    {1, 70, 54, 71, 83, 51, 54, 69, 16, 92, 33, 48, 61, 43, 52, 1, 89, 19, 67, 48},
  };
  uint32_t largest_product = 0;
  uint32_t row_prod = 0;
  uint32_t col_prod = 0;
  uint32_t diag_left_prod = 0;
  uint32_t diag_right_prod = 0;
  
  for (uint row = 0; row < matrix.size(); ++row) {
    for (uint col = 0; col < matrix[col].size(); ++col) {
      if (row < 17)
        row_prod = matrix[row][col] * matrix[row+1][col] *
        matrix[row+2][col] * matrix[row+3][col];
      
      if(col < 17)
        col_prod = matrix[row][col] * matrix[row][col+1] *
        matrix[row][col+2] * matrix[row][col+3];
      
      if((col < 17) && (row < 17))
        diag_right_prod = matrix[row][col] * matrix[row+1][col+1] *
        matrix[row+2][col+2] * matrix[row+3][col+3];
      
      if((col < 17)  && (row < 17) && (col > 3))
        diag_left_prod = matrix[row][col] * matrix[row+1][col-1] *
        matrix[row+2][col-2] * matrix[row+3][col-3];
      
      largest_product = std::max(largest_product, row_prod);
      largest_product = std::max(largest_product, col_prod);
      largest_product = std::max(largest_product, diag_left_prod);
      largest_product = std::max(largest_product, diag_right_prod);
      
    }
  }
  return largest_product;
}

// What is the value of the first triangle number to have over five hundred divisors?
uint32_t prob12() {
  
  uint32_t triangle_num = 0;
  uint32_t num_divisors = 0;
  uint32_t count = 1;
  while (num_divisors < 500) {
    triangle_num = 0;
    num_divisors = 0;
    
    for (uint32_t i = 0; i < count; ++i)
      
      triangle_num = triangle_num + i;
    
    for (uint i = 1; i*i <= triangle_num; ++i)
      if (triangle_num % i == 0)
        num_divisors+=2;
      // std::cout << "number: " << triangle_num << " divisors : " << num_divisors << std::endl;
    ++count;
  }
  return triangle_num;
}


uint64_t prob13() {
  std::vector<std::vector<uint64_t>> numbers = {
    {3,7,1,0,7,2,8,7,5,3,3,9,0,2,1,0,2,7,9,8,7,9,7,9,9,8,2,2,0,8,3,7,5,9,0,2,4,6,5,1,0,1,3,5,7,4,0,2,5,0},
    {4,6,3,7,6,9,3,7,6,7,7,4,9,0,0,0,9,7,1,2,6,4,8,1,2,4,8,9,6,9,7,0,0,7,8,0,5,0,4,1,7,0,1,8,2,6,0,5,3,8},
    {7,4,3,2,4,9,8,6,1,9,9,5,2,4,7,4,1,0,5,9,4,7,4,2,3,3,3,0,9,5,1,3,0,5,8,1,2,3,7,2,6,6,1,7,3,0,9,6,2,9},
    {9,1,9,4,2,2,1,3,3,6,3,5,7,4,1,6,1,5,7,2,5,2,2,4,3,0,5,6,3,3,0,1,8,1,1,0,7,2,4,0,6,1,5,4,9,0,8,2,5,0},
    {2,3,0,6,7,5,8,8,2,0,7,5,3,9,3,4,6,1,7,1,1,7,1,9,8,0,3,1,0,4,2,1,0,4,7,5,1,3,7,7,8,0,6,3,2,4,6,6,7,6},
    {8,9,2,6,1,6,7,0,6,9,6,6,2,3,6,3,3,8,2,0,1,3,6,3,7,8,4,1,8,3,8,3,6,8,4,1,7,8,7,3,4,3,6,1,7,2,6,7,5,7},
    {2,8,1,1,2,8,7,9,8,1,2,8,4,9,9,7,9,4,0,8,0,6,5,4,8,1,9,3,1,5,9,2,6,2,1,6,9,1,2,7,5,8,8,9,8,3,2,7,3,8},
    {4,4,2,7,4,2,2,8,9,1,7,4,3,2,5,2,0,3,2,1,9,2,3,5,8,9,4,2,2,8,7,6,7,9,6,4,8,7,6,7,0,2,7,2,1,8,9,3,1,8},
    {4,7,4,5,1,4,4,5,7,3,6,0,0,1,3,0,6,4,3,9,0,9,1,1,6,7,2,1,6,8,5,6,8,4,4,5,8,8,7,1,1,6,0,3,1,5,3,2,7,6},
    {7,0,3,8,6,4,8,6,1,0,5,8,4,3,0,2,5,4,3,9,9,3,9,6,1,9,8,2,8,9,1,7,5,9,3,6,6,5,6,8,6,7,5,7,9,3,4,9,5,1},
    {6,2,1,7,6,4,5,7,1,4,1,8,5,6,5,6,0,6,2,9,5,0,2,1,5,7,2,2,3,1,9,6,5,8,6,7,5,5,0,7,9,3,2,4,1,9,3,3,3,1},
    {6,4,9,0,6,3,5,2,4,6,2,7,4,1,9,0,4,9,2,9,1,0,1,4,3,2,4,4,5,8,1,3,8,2,2,6,6,3,3,4,7,9,4,4,7,5,8,1,7,8},
    {9,2,5,7,5,8,6,7,7,1,8,3,3,7,2,1,7,6,6,1,9,6,3,7,5,1,5,9,0,5,7,9,2,3,9,7,2,8,2,4,5,5,9,8,8,3,8,4,0,7},
    {5,8,2,0,3,5,6,5,3,2,5,3,5,9,3,9,9,0,0,8,4,0,2,6,3,3,5,6,8,9,4,8,8,3,0,1,8,9,4,5,8,6,2,8,2,2,7,8,2,8},
    {8,0,1,8,1,1,9,9,3,8,4,8,2,6,2,8,2,0,1,4,2,7,8,1,9,4,1,3,9,9,4,0,5,6,7,5,8,7,1,5,1,1,7,0,0,9,4,3,9,0},
    {3,5,3,9,8,6,6,4,3,7,2,8,2,7,1,1,2,6,5,3,8,2,9,9,8,7,2,4,0,7,8,4,4,7,3,0,5,3,1,9,0,1,0,4,2,9,3,5,8,6},
    {8,6,5,1,5,5,0,6,0,0,6,2,9,5,8,6,4,8,6,1,5,3,2,0,7,5,2,7,3,3,7,1,9,5,9,1,9,1,4,2,0,5,1,7,2,5,5,8,2,9},
    {7,1,6,9,3,8,8,8,7,0,7,7,1,5,4,6,6,4,9,9,1,1,5,5,9,3,4,8,7,6,0,3,5,3,2,9,2,1,7,1,4,9,7,0,0,5,6,9,3,8},
    {5,4,3,7,0,0,7,0,5,7,6,8,2,6,6,8,4,6,2,4,6,2,1,4,9,5,6,5,0,0,7,6,4,7,1,7,8,7,2,9,4,4,3,8,3,7,7,6,0,4},
    {5,3,2,8,2,6,5,4,1,0,8,7,5,6,8,2,8,4,4,3,1,9,1,1,9,0,6,3,4,6,9,4,0,3,7,8,5,5,2,1,7,7,7,9,2,9,5,1,4,5},
    {3,6,1,2,3,2,7,2,5,2,5,0,0,0,2,9,6,0,7,1,0,7,5,0,8,2,5,6,3,8,1,5,6,5,6,7,1,0,8,8,5,2,5,8,3,5,0,7,2,1},
    {4,5,8,7,6,5,7,6,1,7,2,4,1,0,9,7,6,4,4,7,3,3,9,1,1,0,6,0,7,2,1,8,2,6,5,2,3,6,8,7,7,2,2,3,6,3,6,0,4,5},
    {1,7,4,2,3,7,0,6,9,0,5,8,5,1,8,6,0,6,6,0,4,4,8,2,0,7,6,2,1,2,0,9,8,1,3,2,8,7,8,6,0,7,3,3,9,6,9,4,1,2},
    {8,1,1,4,2,6,6,0,4,1,8,0,8,6,8,3,0,6,1,9,3,2,8,4,6,0,8,1,1,1,9,1,0,6,1,5,5,6,9,4,0,5,1,2,6,8,9,6,9,2},
    {5,1,9,3,4,3,2,5,4,5,1,7,2,8,3,8,8,6,4,1,9,1,8,0,4,7,0,4,9,2,9,3,2,1,5,0,5,8,6,4,2,5,6,3,0,4,9,4,8,3},
    {6,2,4,6,7,2,2,1,6,4,8,4,3,5,0,7,6,2,0,1,7,2,7,9,1,8,0,3,9,9,4,4,6,9,3,0,0,4,7,3,2,9,5,6,3,4,0,6,9,1},
    {1,5,7,3,2,4,4,4,3,8,6,9,0,8,1,2,5,7,9,4,5,1,4,0,8,9,0,5,7,7,0,6,2,2,9,4,2,9,1,9,7,1,0,7,9,2,8,2,0,9},
    {5,5,0,3,7,6,8,7,5,2,5,6,7,8,7,7,3,0,9,1,8,6,2,5,4,0,7,4,4,9,6,9,8,4,4,5,0,8,3,3,0,3,9,3,6,8,2,1,2,6},
    {1,8,3,3,6,3,8,4,8,2,5,3,3,0,1,5,4,6,8,6,1,9,6,1,2,4,3,4,8,7,6,7,6,8,1,2,9,7,5,3,4,3,7,5,9,4,6,5,1,5},
    {8,0,3,8,6,2,8,7,5,9,2,8,7,8,4,9,0,2,0,1,5,2,1,6,8,5,5,5,4,8,2,8,7,1,7,2,0,1,2,1,9,2,5,7,7,6,6,9,5,4},
    {7,8,1,8,2,8,3,3,7,5,7,9,9,3,1,0,3,6,1,4,7,4,0,3,5,6,8,5,6,4,4,9,0,9,5,5,2,7,0,9,7,8,6,4,7,9,7,5,8,1},
    {1,6,7,2,6,3,2,0,1,0,0,4,3,6,8,9,7,8,4,2,5,5,3,5,3,9,9,2,0,9,3,1,8,3,7,4,4,1,4,9,7,8,0,6,8,6,0,9,8,4},
    {4,8,4,0,3,0,9,8,1,2,9,0,7,7,7,9,1,7,9,9,0,8,8,2,1,8,7,9,5,3,2,7,3,6,4,4,7,5,6,7,5,5,9,0,8,4,8,0,3,0},
    {8,7,0,8,6,9,8,7,5,5,1,3,9,2,7,1,1,8,5,4,5,1,7,0,7,8,5,4,4,1,6,1,8,5,2,4,2,4,3,2,0,6,9,3,1,5,0,3,3,2},
    {5,9,9,5,9,4,0,6,8,9,5,7,5,6,5,3,6,7,8,2,1,0,7,0,7,4,9,2,6,9,6,6,5,3,7,6,7,6,3,2,6,2,3,5,4,4,7,2,1,0},
    {6,9,7,9,3,9,5,0,6,7,9,6,5,2,6,9,4,7,4,2,5,9,7,7,0,9,7,3,9,1,6,6,6,9,3,7,6,3,0,4,2,6,3,3,9,8,7,0,8,5},
    {4,1,0,5,2,6,8,4,7,0,8,2,9,9,0,8,5,2,1,1,3,9,9,4,2,7,3,6,5,7,3,4,1,1,6,1,8,2,7,6,0,3,1,5,0,0,1,2,7,1},
    {6,5,3,7,8,6,0,7,3,6,1,5,0,1,0,8,0,8,5,7,0,0,9,1,4,9,9,3,9,5,1,2,5,5,7,0,2,8,1,9,8,7,4,6,0,0,4,3,7,5},
    {3,5,8,2,9,0,3,5,3,1,7,4,3,4,7,1,7,3,2,6,9,3,2,1,2,3,5,7,8,1,5,4,9,8,2,6,2,9,7,4,2,5,5,2,7,3,7,3,0,7},
    {9,4,9,5,3,7,5,9,7,6,5,1,0,5,3,0,5,9,4,6,9,6,6,0,6,7,6,8,3,1,5,6,5,7,4,3,7,7,1,6,7,4,0,1,8,7,5,2,7,5},
    {8,8,9,0,2,8,0,2,5,7,1,7,3,3,2,2,9,6,1,9,1,7,6,6,6,8,7,1,3,8,1,9,9,3,1,8,1,1,0,4,8,7,7,0,1,9,0,2,7,1},
    {2,5,2,6,7,6,8,0,2,7,6,0,7,8,0,0,3,0,1,3,6,7,8,6,8,0,9,9,2,5,2,5,4,6,3,4,0,1,0,6,1,6,3,2,8,6,6,5,2,6},
    {3,6,2,7,0,2,1,8,5,4,0,4,9,7,7,0,5,5,8,5,6,2,9,9,4,6,5,8,0,6,3,6,2,3,7,9,9,3,1,4,0,7,4,6,2,5,5,9,6,2},
    {2,4,0,7,4,4,8,6,9,0,8,2,3,1,1,7,4,9,7,7,7,9,2,3,6,5,4,6,6,2,5,7,2,4,6,9,2,3,3,2,2,8,1,0,9,1,7,1,4,1},
    {9,1,4,3,0,2,8,8,1,9,7,1,0,3,2,8,8,5,9,7,8,0,6,6,6,9,7,6,0,8,9,2,9,3,8,6,3,8,2,8,5,0,2,5,3,3,3,4,0,3},
    {3,4,4,1,3,0,6,5,5,7,8,0,1,6,1,2,7,8,1,5,9,2,1,8,1,5,0,0,5,5,6,1,8,6,8,8,3,6,4,6,8,4,2,0,0,9,0,4,7,0},
    {2,3,0,5,3,0,8,1,1,7,2,8,1,6,4,3,0,4,8,7,6,2,3,7,9,1,9,6,9,8,4,2,4,8,7,2,5,5,0,3,6,6,3,8,7,8,4,5,8,3},
    {1,1,4,8,7,6,9,6,9,3,2,1,5,4,9,0,2,8,1,0,4,2,4,0,2,0,1,3,8,3,3,5,1,2,4,4,6,2,1,8,1,4,4,1,7,7,3,4,7,0},
    {6,3,7,8,3,2,9,9,4,9,0,6,3,6,2,5,9,6,6,6,4,9,8,5,8,7,6,1,8,2,2,1,2,2,5,2,2,5,5,1,2,4,8,6,7,6,4,5,3,3},
    {6,7,7,2,0,1,8,6,9,7,1,6,9,8,5,4,4,3,1,2,4,1,9,5,7,2,4,0,9,9,1,3,9,5,9,0,0,8,9,5,2,3,1,0,0,5,8,8,2,2},
    {9,5,5,4,8,2,5,5,3,0,0,2,6,3,5,2,0,7,8,1,5,3,2,2,9,6,7,9,6,2,4,9,4,8,1,6,4,1,9,5,3,8,6,8,2,1,8,7,7,4},
    {7,6,0,8,5,3,2,7,1,3,2,2,8,5,7,2,3,1,1,0,4,2,4,8,0,3,4,5,6,1,2,4,8,6,7,6,9,7,0,6,4,5,0,7,9,9,5,2,3,6},
    {3,7,7,7,4,2,4,2,5,3,5,4,1,1,2,9,1,6,8,4,2,7,6,8,6,5,5,3,8,9,2,6,2,0,5,0,2,4,9,1,0,3,2,6,5,7,2,9,6,7},
    {2,3,7,0,1,9,1,3,2,7,5,7,2,5,6,7,5,2,8,5,6,5,3,2,4,8,2,5,8,2,6,5,4,6,3,0,9,2,2,0,7,0,5,8,5,9,6,5,2,2},
    {2,9,7,9,8,8,6,0,2,7,2,2,5,8,3,3,1,9,1,3,1,2,6,3,7,5,1,4,7,3,4,1,9,9,4,8,8,9,5,3,4,7,6,5,7,4,5,5,0,1},
    {1,8,4,9,5,7,0,1,4,5,4,8,7,9,2,8,8,9,8,4,8,5,6,8,2,7,7,2,6,0,7,7,7,1,3,7,2,1,4,0,3,7,9,8,8,7,9,7,1,5},
    {3,8,2,9,8,2,0,3,7,8,3,0,3,1,4,7,3,5,2,7,7,2,1,5,8,0,3,4,8,1,4,4,5,1,3,4,9,1,3,7,3,2,2,6,6,5,1,3,8,1},
    {3,4,8,2,9,5,4,3,8,2,9,1,9,9,9,1,8,1,8,0,2,7,8,9,1,6,5,2,2,4,3,1,0,2,7,3,9,2,2,5,1,1,2,2,8,6,9,5,3,9},
    {4,0,9,5,7,9,5,3,0,6,6,4,0,5,2,3,2,6,3,2,5,3,8,0,4,4,1,0,0,0,5,9,6,5,4,9,3,9,1,5,9,8,7,9,5,9,3,6,3,5},
    {2,9,7,4,6,1,5,2,1,8,5,5,0,2,3,7,1,3,0,7,6,4,2,2,5,5,1,2,1,1,8,3,6,9,3,8,0,3,5,8,0,3,8,8,5,8,4,9,0,3},
    {4,1,6,9,8,1,1,6,2,2,2,0,7,2,9,7,7,1,8,6,1,5,8,2,3,6,6,7,8,4,2,4,6,8,9,1,5,7,9,9,3,5,3,2,9,6,1,9,2,2},
    {6,2,4,6,7,9,5,7,1,9,4,4,0,1,2,6,9,0,4,3,8,7,7,1,0,7,2,7,5,0,4,8,1,0,2,3,9,0,8,9,5,5,2,3,5,9,7,4,5,7},
    {2,3,1,8,9,7,0,6,7,7,2,5,4,7,9,1,5,0,6,1,5,0,5,5,0,4,9,5,3,9,2,2,9,7,9,5,3,0,9,0,1,1,2,9,9,6,7,5,1,9},
    {8,6,1,8,8,0,8,8,2,2,5,8,7,5,3,1,4,5,2,9,5,8,4,0,9,9,2,5,1,2,0,3,8,2,9,0,0,9,4,0,7,7,7,0,7,7,5,6,7,2},
    {1,1,3,0,6,7,3,9,7,0,8,3,0,4,7,2,4,4,8,3,8,1,6,5,3,3,8,7,3,5,0,2,3,4,0,8,4,5,6,4,7,0,5,8,0,7,7,3,0,8},
    {8,2,9,5,9,1,7,4,7,6,7,1,4,0,3,6,3,1,9,8,0,0,8,1,8,7,1,2,9,0,1,1,8,7,5,4,9,1,3,1,0,5,4,7,1,2,6,5,8,1},
    {9,7,6,2,3,3,3,1,0,4,4,8,1,8,3,8,6,2,6,9,5,1,5,4,5,6,3,3,4,9,2,6,3,6,6,5,7,2,8,9,7,5,6,3,4,0,0,5,0,0},
    {4,2,8,4,6,2,8,0,1,8,3,5,1,7,0,7,0,5,2,7,8,3,1,8,3,9,4,2,5,8,8,2,1,4,5,5,2,1,2,2,7,2,5,1,2,5,0,3,2,7},
    {5,5,1,2,1,6,0,3,5,4,6,9,8,1,2,0,0,5,8,1,7,6,2,1,6,5,2,1,2,8,2,7,6,5,2,7,5,1,6,9,1,2,9,6,8,9,7,7,8,9},
    {3,2,2,3,8,1,9,5,7,3,4,3,2,9,3,3,9,9,4,6,4,3,7,5,0,1,9,0,7,8,3,6,9,4,5,7,6,5,8,8,3,3,5,2,3,9,9,8,8,6},
    {7,5,5,0,6,1,6,4,9,6,5,1,8,4,7,7,5,1,8,0,7,3,8,1,6,8,8,3,7,8,6,1,0,9,1,5,2,7,3,5,7,9,2,9,7,0,1,3,3,7},
    {6,2,1,7,7,8,4,2,7,5,2,1,9,2,6,2,3,4,0,1,9,4,2,3,9,9,6,3,9,1,6,8,0,4,4,9,8,3,9,9,3,1,7,3,3,1,2,7,3,1},
    {3,2,9,2,4,1,8,5,7,0,7,1,4,7,3,4,9,5,6,6,9,1,6,6,7,4,6,8,7,6,3,4,6,6,0,9,1,5,0,3,5,9,1,4,6,7,7,5,0,4},
    {9,9,5,1,8,6,7,1,4,3,0,2,3,5,2,1,9,6,2,8,8,9,4,8,9,0,1,0,2,4,2,3,3,2,5,1,1,6,9,1,3,6,1,9,6,2,6,6,2,2},
    {7,3,2,6,7,4,6,0,8,0,0,5,9,1,5,4,7,4,7,1,8,3,0,7,9,8,3,9,2,8,6,8,5,3,5,2,0,6,9,4,6,9,4,4,5,4,0,7,2,4},
    {7,6,8,4,1,8,2,2,5,2,4,6,7,4,4,1,7,1,6,1,5,1,4,0,3,6,4,2,7,9,8,2,2,7,3,3,4,8,0,5,5,5,5,6,2,1,4,8,1,8},
    {9,7,1,4,2,6,1,7,9,1,0,3,4,2,5,9,8,6,4,7,2,0,4,5,1,6,8,9,3,9,8,9,4,2,2,1,7,9,8,2,6,0,8,8,0,7,6,8,5,2},
    {8,7,7,8,3,6,4,6,1,8,2,7,9,9,3,4,6,3,1,3,7,6,7,7,5,4,3,0,7,8,0,9,3,6,3,3,3,3,0,1,8,9,8,2,6,4,2,0,9,0},
    {1,0,8,4,8,8,0,2,5,2,1,6,7,4,6,7,0,8,8,3,2,1,5,1,2,0,1,8,5,8,8,3,5,4,3,2,2,3,8,1,2,8,7,6,9,5,2,7,8,6},
    {7,1,3,2,9,6,1,2,4,7,4,7,8,2,4,6,4,5,3,8,6,3,6,9,9,3,0,0,9,0,4,9,3,1,0,3,6,3,6,1,9,7,6,3,8,7,8,0,3,9},
    {6,2,1,8,4,0,7,3,5,7,2,3,9,9,7,9,4,2,2,3,4,0,6,2,3,5,3,9,3,8,0,8,3,3,9,6,5,1,3,2,7,4,0,8,0,1,1,1,1,6},
    {6,6,6,2,7,8,9,1,9,8,1,4,8,8,0,8,7,7,9,7,9,4,1,8,7,6,8,7,6,1,4,4,2,3,0,0,3,0,9,8,4,4,9,0,8,5,1,4,1,1},
    {6,0,6,6,1,8,2,6,2,9,3,6,8,2,8,3,6,7,6,4,7,4,4,7,7,9,2,3,9,1,8,0,3,3,5,1,1,0,9,8,9,0,6,9,7,9,0,7,1,4},
    {8,5,7,8,6,9,4,4,0,8,9,5,5,2,9,9,0,6,5,3,6,4,0,4,4,7,4,2,5,5,7,6,0,8,3,6,5,9,9,7,6,6,4,5,7,9,5,0,9,6},
    {6,6,0,2,4,3,9,6,4,0,9,9,0,5,3,8,9,6,0,7,1,2,0,1,9,8,2,1,9,9,7,6,0,4,7,5,9,9,4,9,0,1,9,7,2,3,0,2,9,7},
    {6,4,9,1,3,9,8,2,6,8,0,0,3,2,9,7,3,1,5,6,0,3,7,1,2,0,0,4,1,3,7,7,9,0,3,7,8,5,5,6,6,0,8,5,0,8,9,2,5,2},
    {1,6,7,3,0,9,3,9,3,1,9,8,7,2,7,5,0,2,7,5,4,6,8,9,0,6,9,0,3,7,0,7,5,3,9,4,1,3,0,4,2,6,5,2,3,1,5,0,1,1},
    {9,4,8,0,9,3,7,7,2,4,5,0,4,8,7,9,5,1,5,0,9,5,4,1,0,0,9,2,1,6,4,5,8,6,3,7,5,4,7,1,0,5,9,8,4,3,6,7,9,1},
    {7,8,6,3,9,1,6,7,0,2,1,1,8,7,4,9,2,4,3,1,9,9,5,7,0,0,6,4,1,9,1,7,9,6,9,7,7,7,5,9,9,0,2,8,3,0,0,6,9,9},
    {1,5,3,6,8,7,1,3,7,1,1,9,3,6,6,1,4,9,5,2,8,1,1,3,0,5,8,7,6,3,8,0,2,7,8,4,1,0,7,5,4,4,4,9,7,3,3,0,7,8},
    {4,0,7,8,9,9,2,3,1,1,5,5,3,5,5,6,2,5,6,1,1,4,2,3,2,2,4,2,3,2,5,5,0,3,3,6,8,5,4,4,2,4,8,8,9,1,7,3,5,3},
    {4,4,8,8,9,9,1,1,5,0,1,4,4,0,6,4,8,0,2,0,3,6,9,0,6,8,0,6,3,9,6,0,6,7,2,3,2,2,1,9,3,2,0,4,1,4,9,5,3,5},
    {4,1,5,0,3,1,2,8,8,8,0,3,3,9,5,3,6,0,5,3,2,9,9,3,4,0,3,6,8,0,0,6,9,7,7,7,1,0,6,5,0,5,6,6,6,3,1,9,5,4},
    {8,1,2,3,4,8,8,0,6,7,3,2,1,0,1,4,6,7,3,9,0,5,8,5,6,8,5,5,7,9,3,4,5,8,1,4,0,3,6,2,7,8,2,2,7,0,3,2,8,0},
    {8,2,6,1,6,5,7,0,7,7,3,9,4,8,3,2,7,5,9,2,2,3,2,8,4,5,9,4,1,7,0,6,5,2,5,0,9,4,5,1,2,3,2,5,2,3,0,6,0,8},
    {2,2,9,1,8,8,0,2,0,5,8,7,7,7,3,1,9,7,1,9,8,3,9,4,5,0,1,8,0,8,8,8,0,7,2,4,2,9,6,6,1,9,8,0,8,1,1,1,9,7},
    {7,7,1,5,8,5,4,2,5,0,2,0,1,6,5,4,5,0,9,0,4,1,3,2,4,5,8,0,9,7,8,6,8,8,2,7,7,8,9,4,8,7,2,1,8,5,9,6,1,7},
    {7,2,1,0,7,8,3,8,4,3,5,0,6,9,1,8,6,1,5,5,4,3,5,6,6,2,8,8,4,0,6,2,2,5,7,4,7,3,6,9,2,2,8,4,5,0,9,5,1,6},
    {2,0,8,4,9,6,0,3,9,8,0,1,3,4,0,0,1,7,2,3,9,3,0,6,7,1,6,6,6,8,2,3,5,5,5,2,4,5,2,5,2,8,0,4,6,0,9,7,2,2},
    {5,3,5,0,3,5,3,4,2,2,6,4,7,2,5,2,4,2,5,0,8,7,4,0,5,4,0,7,5,5,9,1,7,8,9,7,8,1,2,6,4,3,3,0,3,3,1,6,9,0}
  };
  // do the count forward  carry backward trick with this one
  // so we only need to look at first 11 numbers in each row
  
  std::string this_line;
  uint64_t last_line =0;
  
  for (int i = 0; i < 100; ++i) {
    this_line = "";
    for (int j = 0; j < 11 ; ++j) {
      this_line += std::to_string(numbers[i][j]);
    }
    last_line += std::stoll(this_line);
    //    std::cout << this_line << " " << last_line << std::endl;
  }
  return last_line;
}

unsigned long long prob14() {
  unsigned long long chain = 0;
  unsigned long long longest_chain = 0;
  unsigned long long start = 0;
  unsigned long long finish = 1000000;
  
  for (unsigned long long i = 1; i < finish; ++i) {
    unsigned long long j = i;
    chain = 0;
    while (j > 1) {
      if (j % 2 == 0) {
        j = j/2;
        ++chain;
      } else {
        j = (3*j) +1;
        ++chain;
      }
    }
    if (chain > longest_chain) {
      start = i;
      longest_chain = chain;
    }
    
  }
  return start;
}

unsigned long long factorial(unsigned long long num) {
  unsigned long long answer = 1;
  for (unsigned long long i = 1; i <= num; ++i)
    answer = answer * i;
  return answer;
}

unsigned long long prob15() {
  //   unsigned long long  routes = 0;
  //   uint16_t grid_length = 20;
  //   // pascal triangle
  //   unsigned long long num = factorial(20);
  //   routes =  factorial(40) /(num*num);
  //   std::cout << factorial(40) << " " << num << std::endl;
  //   return routes;
  //precision error cannot factorise 40
  // should be 137846528820
  // got right answer with python
  //  one liner math.factorial(40)/(math.factorial(20)*math.factorial(20))
  
  //Here is another way
  unsigned long long grid[20][20];
  for (int i = 0; i < 20; ++i) {
    grid[20][i] = 1;
    grid[i][19] = 1;
  }
  for (int i = 19; i>=0; --i)
    for(int j=19; j>=0; --j)
      grid[i][j]=grid[i+1][j]+ grid[i][j+1];
    std::cout << grid[0][0];
  return 0;
}

size_t prob16() {
  std::string n;
  
  // Calculate 2**1000
  n.push_back( 2 );
  for (unsigned cntr = 1; cntr < 1000; cntr++) {
    std::transform(n.begin(), n.end(), n.begin(), std::bind2nd( std::multiplies <char> (),  2 ) );
    if (n[n.size()-1] > 9)
      n.push_back( 0 );
    std::adjacent_difference( n.begin(), n.end(), n.begin(), std::ptr_fun( &carry ));
    std::transform(n.begin(), n.end(), n.begin(), std::bind2nd( std::modulus    <char> (), 10 ) );
  }
  // Get the sum of the digits
  size_t sum_of_digits = std::accumulate( n.begin(), n.end(), 0 );
  return sum_of_digits;
}

size_t prob18() {
  std::vector<std::vector<size_t>> triangle = {
    { 75 },
    { 95, 64 },
    { 17, 47, 82 },
    { 18, 35, 87, 10 },
    { 20, 4, 82, 47, 65 },
    { 19, 01, 23, 75, 3, 34 },
    { 88, 2, 77, 73,  7, 63, 67 },
    { 99, 65, 4, 28,  6, 16, 70, 92 },
    { 41, 41, 26, 56, 83, 40, 80, 70, 33 },
    { 41, 48, 72, 33, 47, 32, 37, 16, 94, 29 },
    { 53, 71, 44, 65, 25, 43, 91, 52, 97, 51, 14 },
    { 70, 11, 33, 28, 77, 73, 17, 78, 39, 68, 17, 57 },
    { 91, 71, 52, 38, 17, 14, 91, 43, 58, 50, 27, 29, 48 },
    { 63, 66, 04, 68, 89, 53, 67, 30, 73, 16, 69, 87, 40, 31 },
    { 4,  62, 98, 27, 23, 9,  70, 98, 73, 93, 38, 53, 60,  4, 23 }
  };
  for(uint i = 0; i  < triangle.size(); ++i) {
    for (uint j = 0; j < triangle[i].size(); ++j ) {
      
    }
  }
  return 0;
}

int prob19() {

  return 0;
}

size_t prob20() {
  int i, j, k;
  int n = 100;
  int factorial[10000];
  
  factorial[0] = 1;
  k = 0;
  for(i = 2; i <= n; i++)  {
    for(j = 0; j <= k; j++)
      factorial[j] *= i;
    for(j = 0; j <= k; j++) {
      if(factorial[j] >= 10) {
        factorial[j+1] += (factorial[j] - (factorial[j] % 10)) / 10;
        factorial[j] = factorial[j] % 10;
        if(j == k)
          k++;
      }
    }
  }
  std::string out = std::to_string(*factorial);
  // Get the sum of the digits
  
  size_t sum_of_digits = std::accumulate( out.begin(), out.end(), 0 );
  return sum_of_digits;
}




// #######################################################################
// ################## MAIN ################################################
int main() {
  static_assert(std::numeric_limits<u_int>::digits >= 31, "Int is not at least 32 bits");
  static_assert(std::numeric_limits<unsigned long>::digits >= 32, "Long is not at least 32 bits");
  static_assert(std::numeric_limits<unsigned long long>::digits >= 64, "Long Long is not at least 64 bits");
  static_assert(std::numeric_limits<uint64_t>::digits >= 64, "Int_64t is not at least 64 bits");
  static_assert(std::numeric_limits<uint32_t>::digits >= 32, "Int_32t is not at least 16 bits");
  std::cout << "Prob 1: " << prob1() << std::endl;
  std::cout << "Prob 2: " << prob2() << std::endl;
  std::cout << "Prob 3: " << prob3() << std::endl;
  std::cout << "Prob 4: " << prob4() << std::endl;
  std::cout << "Prob 5: " << prob5() << std::endl;
  std::cout << "Prob 6: " << prob6() << std::endl;
  std::cout << "Prob 7: " << prob7() << std::endl;
  std::cout << "Prob 8: " << prob8() << std::endl;
  std::cout << "Prob 9: " << prob9() << std::endl;
  std::cout << "Prob 10: " << prob10() << std::endl;
  std::cout << "Prob 11: " << prob11() << std::endl;
  std::cout << "Prob 12: " << prob12() << std::endl;
  std::cout << "Prob 13: " << prob13() << std::endl;
  std::cout << "Prob 14: " << prob14() << std::endl;
  //std::cout << "Prob 15: " << prob15() << std::endl;
  std::cout << "Prob 16: " << prob16() << std::endl;
  std::cout << "Prob 18: " << prob18() << std::endl;
  std::cout << "Prob 20: " << prob20() << std::endl;
  int a;
  std::move(a);
  std::bitset<10> Bit;
  return 0;
  
  //    return 0;
}
